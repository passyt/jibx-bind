package org.jibx.binding.model;

/**
 * The include element allows modular binding definitions by specifying another
 * binding to be read as part of the current binding definition. Since 1.2, it
 * also allows for bindings to be separately compiled.<br/>
 * <br/>
 * 
 * Top-level format and mapping definitions from the included binding are
 * treated the same as if they'd been present in the original binding, as
 * children of the binding element. namespace definitions, on the other hand,
 * apply downward only: Top-level namespace definitions in the original binding
 * apply to the included binding just as if they were directly present, but
 * namespace definitions within the included binding do not apply back to the
 * original binding. This makes it easy to structure bindings corresponding to
 * different namespaces, and to combine these bindings without namespace
 * conflicts.<br/>
 * <br/>
 * 
 * include elements can also be used within included bindings, and circular
 * references are allowed.
 * 
 * @author Passyt
 *
 */
public class IncludeElement extends NestingElementBase implements BindingChild {

	/**
	 * The path for the binding definition to be included. This may be an
	 * absolute path, or a path relative to the including binding definition.
	 * Any type of URL reference can be used for the path, including classpath:
	 * URLs to access bindings from the classpath (especially useful when
	 * working with modular bindings). If you're using file paths on Windows and
	 * want to specify the absolute path (such as C:/some/directory/file.xml)
	 * you'll need to convert this into a valid URL reference by using either
	 * '/' or 'file:///' as a prefix (so /C:/some/directory/file.xml or
	 * file:///C:/some/directory/file.xml).
	 */
	private String path;
	/**
	 * Flag used when including a precompiled binding. If the value is "true",
	 * the included binding must have been compiled previously and the classes
	 * used by that binding (including the extra classes generated by the
	 * binding compiler) must be present in the classpath. See the full
	 * discussion of precompiled bindings for details.
	 */
	private boolean precompiled;

	private transient BindingElement bindingElement;

	public IncludeElement() {
		super(ElementType.Include);
	}

	public String getPath() {
		return path;
	}

	public void setPath(String path) {
		this.path = path;
	}

	public boolean isPrecompiled() {
		return precompiled;
	}

	public void setPrecompiled(boolean precompiled) {
		this.precompiled = precompiled;
	}

	public BindingElement getBindingElement() {
		return bindingElement;
	}

	public void setBindingElement(BindingElement bindingElement) {
		this.bindingElement = bindingElement;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		result = prime * result + ((path == null) ? 0 : path.hashCode());
		result = prime * result + (precompiled ? 1231 : 1237);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (!super.equals(obj))
			return false;
		if (getClass() != obj.getClass())
			return false;
		IncludeElement other = (IncludeElement) obj;
		if (path == null) {
			if (other.path != null)
				return false;
		} else if (!path.equals(other.path))
			return false;
		if (precompiled != other.precompiled)
			return false;
		return true;
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("IncludeElement [path=").append(path).append(", precompiled=").append(precompiled).append(", attributes=").append(attributes).append(", nestingChildren=")
				.append(nestingChildren).append(", type=").append(type).append(", comment=").append(comment).append("]");
		return builder.toString();
	}

}
